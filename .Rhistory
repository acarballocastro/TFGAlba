# Apartado c ----
# Determinar medidas de bondad de ajuste del MDS reteniendo k autovalores,
# con k=1,2,3,4,5. Mantener el número de dimensiones tal que los la suma de los
# autovalores asociados represente al menos el 80% del total de autovalores
# positivos, o bien el 75% del total de los autovalores en valor absoluto
nv = 5
GOF = matrix(0,nv,2)
for (i in 1:nv){
GOF[i,] = cmdscale(distEur,k=i,eig=TRUE)$GOF}
GOF
rownames(GOF)=1:nv
colnames(GOF)=c("Totaval_abs","Totaval_pos")
GOF
matplot(GOF,type="l",col=c("blue","red"))
legend("bottomright",col=c("blue","red"),
legend=c("Total abs","Total pos"), lty = 2)
abline(h=0.75,lwd=2,col="blue",lty=2)
abline(h=0.8,lwd=2,col="red",lty=2)
# Con k=2, se mantiene el 86,79% del total de autovalores positivos y el 75,37%
# del total de los autovalores en valor absoluto. Se mantiene k=2
# Apartado d ----
# Obtener el plot de las ciudades europeas en las nuevas coordenadas
# Comenzamos con el plot que directamente nos proporcionan las coordenadas
locEur = cmdscale(distEur,k=2,eig=TRUE)
plot(locEur$points,type="n",xlab="Coordenada 1",ylab="Coordenada 2",
asp=1, main = "MDS métrico. Ciudades europeas")
text(locEur$points, rownames(locEur$points), cex = 0.7,col=4)
# El gráfico obtenido nos permite representar las distancias entre ciudades en
# un espacio bidimensional. Sin embargo, la representación no es idéntica a un
# mapa geográfico de Europa: mientras que la coordenada 1 parece representar la
# dirección OESTE(-) ---> ESTE(+), la segunda proporciona un sentido contrario
# al mapa usual: NORTE (-) ---> SUR(+)
NS <- -locEur$points[,2]
EO <-  locEur$points[,1]
plot(EO, NS, type = "n", xlab = "Oeste-Este", ylab = "Sur-Norte", asp=1,
main = "MDS métrico. Ciudades Europeas")
text(EO, NS, rownames(locEur$points), cex = 0.7,col=4)
abline(h=0,lty=2)
abline(v=0,lty=2)
matDist=as.matrix(dist(locEur$points))
# Una nube de puntos para comparar ambas distancias
plot(matDist,distEur,pch=19,col=4)
abline(a=0,b=1,col=2)
#Diferencias entre ambas distancias
matDiff = as.matrix(matDist - distEur)
matDiff
summary(matDiff)
# Determinación de los errores más grandes
(M=which.max(matDiff))
(m=which.min(matDiff))
(Mabs=which.max(abs(matDiff)))
# Los valores:
matDiff[M]
matDiff[m]
matDiff[Mabs]
#Si queremos ver a qué ciudades corresponden
which(matDiff==max(matDiff),arr.ind=TRUE)
which(matDiff==min(matDiff),arr.ind=TRUE)
which(abs(matDiff)==max(abs(matDiff)),arr.ind=TRUE)
library(tidyverse)
library(ggpubr)
library(shapr)
#library(ggforce)
library(caret)
library(xgboost)
library(ranger)
# Plots
source("extra/sina_plot.R")
source("extra/indiv_plot.R")
View(indiv_plot)
View(plot)
View(plot)
View(plot)
# Laboratorio: Escalamiento multidimensional métrico.
# Caso Práctico 1.
# Datos "eurodist". Librería base, o bien "datasets"
# El data set es una matriz de distancias, por carretera,
# entre 27 ciudades europeas (unidad km.)
# Apartado a ----
# Con el objetivo de aplicar el MDS métrico a dicha matriz, obtener la matriz
# doble-centrada B asociada y comprobar si es  semidefinida positiva (todos su
# autovalores deben ser no negativos):
# Lectura de datos
?eurodist
class(eurodist) # Objeto tipo "dist"
str(eurodist)
# eurodist almacena las distancias en un vector en vez de guardar los 21x21
# elementos, solo almacena la mitad triangular (superior o inferior da igual)
# en total 21*20/2=210
# vamos a generar la  matriz de distancias asociada
distEur = as.matrix(eurodist)
class(distEur) # Objeto tipo "matrix"
str(distEur)
distEur[,1:2] #distancias a Atenas y Barcelona
#matriz A = -0.5* D^2
A = -0.5*(distEur)^2
n = nrow(distEur) # Número de ciudades
n
#matrices E, H y B:
E = matrix(1,nrow=n,ncol=n,byrow = TRUE)
H = diag(1,n) - (1/n)*E
B = H%*%A%*%H
eigen(B)$values
# Por tanto, no es semidefinida positiva, por lo que se debe trabajar con las
# componentes asociadas a autovalores positivos.
# Número de autovalores positivos: 11
sum(eigen(B)$values > 0)
# Como mucho podríamos construir 11 dimensiones con las técnicsa de escalamiento
# multidimensional
# Apartado b ----
# Obtener el MDS métrico, determinando una constante que sumada a las distancias
# entre ciudades distintas, proporcione una distancia euclídea, comprobando el resultado
cmdscale(distEur,add=TRUE)$ac  #constante aditiva
distEurnew = distEur + cmdscale(distEur,add=TRUE)$ac
# Hay que sumar para que sea una distancia de tipo euclídea
# La diagonal se debe mantener igual, o sea, 0
diag(distEurnew) = diag(distEur)
cmdscale(distEurnew,add=TRUE,eig=TRUE)$eig
# Todos los autovalores (aproximadamente) son no negativos. El último es muy
# cercano a 0.
# Apartado c ----
# Determinar medidas de bondad de ajuste del MDS reteniendo k autovalores,
# con k=1,2,3,4,5. Mantener el número de dimensiones tal que los la suma de los
# autovalores asociados represente al menos el 80% del total de autovalores
# positivos, o bien el 75% del total de los autovalores en valor absoluto
nv = 5
GOF = matrix(0,nv,2)
for (i in 1:nv){
GOF[i,] = cmdscale(distEur,k=i,eig=TRUE)$GOF}
GOF
rownames(GOF)=1:nv
colnames(GOF)=c("Totaval_abs","Totaval_pos")
GOF
matplot(GOF,type="l",col=c("blue","red"))
legend("bottomright",col=c("blue","red"),
legend=c("Total abs","Total pos"), lty = 2)
abline(h=0.75,lwd=2,col="blue",lty=2)
abline(h=0.8,lwd=2,col="red",lty=2)
# Con k=2, se mantiene el 86,79% del total de autovalores positivos y el 75,37%
# del total de los autovalores en valor absoluto. Se mantiene k=2
# Apartado d ----
# Obtener el plot de las ciudades europeas en las nuevas coordenadas
# Comenzamos con el plot que directamente nos proporcionan las coordenadas
locEur = cmdscale(distEur,k=2,eig=TRUE)
plot(locEur$points,type="n",xlab="Coordenada 1",ylab="Coordenada 2",
asp=1, main = "MDS métrico. Ciudades europeas")
text(locEur$points, rownames(locEur$points), cex = 0.7,col=4)
# El gráfico obtenido nos permite representar las distancias entre ciudades en
# un espacio bidimensional. Sin embargo, la representación no es idéntica a un
# mapa geográfico de Europa: mientras que la coordenada 1 parece representar la
# dirección OESTE(-) ---> ESTE(+), la segunda proporciona un sentido contrario
# al mapa usual: NORTE (-) ---> SUR(+)
NS <- -locEur$points[,2]
EO <-  locEur$points[,1]
plot(EO, NS, type = "n", xlab = "Oeste-Este", ylab = "Sur-Norte", asp=1,
main = "MDS métrico. Ciudades Europeas")
text(EO, NS, rownames(locEur$points), cex = 0.7,col=4)
abline(h=0,lty=2)
abline(v=0,lty=2)
# Apartado e
# Calcular las distancias euclídeas obtenidas y compararlas con las distancias
# kilométricas iniciales
matDist = as.matrix(dist(locEur$points))
# Una nube de puntos para comparar ambas distancias
plot(matDist,distEur,pch=19,col=4)
abline(a=0,b=1,col=2)
#Diferencias entre ambas distancias
matDiff = as.matrix(matDist - distEur)
matDiff
summary(matDiff)
# Determinación de los errores más grandes
(M = which.max(matDiff))
(m = which.min(matDiff))
(Mabs = which.max(abs(matDiff)))
# Los valores:
matDiff[M]
matDiff[m]
matDiff[Mabs]
#Si queremos ver a qué ciudades corresponden
which(matDiff==max(matDiff),arr.ind=TRUE)
which(matDiff==min(matDiff),arr.ind=TRUE)
which(abs(matDiff)==max(abs(matDiff)),arr.ind=TRUE)
# Es importante ver dónde hay una discrepancia elevada en valor absoluto
# Entre Ginebra y COlonia es donde hay mas discrepancia entre distancias
# originales y las calculadas por el MDS
# Una representación gráfica se puede obtener pasando
# las diferencias al intervalo [-1,1]
library(corrplot)
corrplot(matDiff/matDiff[Mabs])
library(tidyverse)
library(ggpubr)
library(shapr)
#library(ggforce)
library(caret)
library(xgboost)
library(ranger)
source("extra/indiv_plot.R")
dataset <- read_csv("data/datasetADNI.csv")
dataset <- dataset[,-1] # Removing ID
head(dataset)
# Fixing covariables and response variable
x_var <- c("FDG","ABETA","PTAU","APOE4","PTGENDER","AGE","PTEDUCAT")
y_var <- "DXB" # Binary classification
# Splitting in train-test (80%-20%)
set.seed(2022)
train_index <- caret::createDataPartition(dataset$DXB, p = .8, list = FALSE, times = 1)
# Training data
x_train <- as.matrix(dataset[train_index, x_var])
y_train <- as.matrix(dataset[train_index, y_var]) # not centered
# Test data
x_test <- as.matrix(dataset[-train_index, x_var])
y_test <- as.matrix(dataset[-train_index, y_var]) # not centered
# Parameters: binary/logistic classification (supported by shapr)
params = list(
objective="binary:logistic",
eval_metric="error"
)
modelxgb <- xgboost(data = x_train, label = y_train, nround = 100,
verbose = FALSE, params = params)
print(modelxgb)
predict(modelxgb, x_test)
explainer_symmetric <- shapr(x_train, modelxgb)
p <- mean(y_train) # Expected prediction
### Causal Shapley values ----
partial_order <- list(c(5,4,6,7), c(2), c(1,3))
explanation_causal <- explain(x_test, approach = "causal",
explainer = explainer_symmetric,
prediction_zero = p, ordering = partial_order,
confounding = c(TRUE, FALSE, TRUE), seed = 2022)
sina_causal <- sina_plot(explanation_causal)
# save limits of sina_causal plot for comparing against marginal and asymmetric
ylim_causal <- sina_causal$coordinates$limits$y
### Marginal Shapley values ----
# Assumes one component with confounding
explanation_marginal <- explain(x_test, approach = "causal",
explainer = explainer_symmetric,
prediction_zero = p, ordering = list(c(1:7)),
confounding = TRUE, seed = 2020)
#install.packages("smacof")
library(smacof)
kinshipdelta
dim(kinshipdelta)
cmdscale(kinshipdelta, eig=TRUE)$eig
cmdscale(kinshipdelta, k=1, eig=TRUE)$GOF
cmdscale(kinshipdelta, k=2, eig=TRUE)$GOF
cmdscale(kinshipdelta, k=3, eig=TRUE)$GOF
cmdscale(kinshipdelta, k=4, eig=TRUE)$GOF
cmdscale(kinshipdelta, k=5, eig=TRUE)$GOF
sina_marginal <- sina_plot(explanation_marginal) +
coord_flip(ylim = ylim_causal) + ggtitle("Marginal Shapley values")
explainer_asymmetric <- shapr(x_train, modelxgb, asymmetric = TRUE, ordering = partial_order)
p <- mean(y_train)
explanation_asymmetric <- explain(x_test, approach = "gaussian",
explainer = explainer_asymmetric,
prediction_zero = p, ordering = partial_order,
asymmetric = TRUE, seed = 2020)
sina_asymmetric <- sina_plot(explanation_asymmetric) +
coord_flip(ylim = ylim_causal) + ggtitle("Asymmetric conditional Shapley values")
explanation_asymmetric_causal <- explain(x_test, approach = "causal",
explainer = explainer_asymmetric,
prediction_zero = p, asymmetric = TRUE,
ordering = partial_order,
confounding = c(TRUE, FALSE, TRUE),
seed = 2020)
sina_asymmetric <- sina_plot(explanation_asymmetric) +
coord_flip(ylim = ylim_causal) + ggtitle("Asymmetric conditional Shapley values")
sina_asymmetric_causal <- sina_plot(explanation_asymmetric_causal) +
coord_flip(ylim = ylim_causal) + ggtitle("Asymmetric causal Shapley values")
plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_causal, plot_phi0 = TRUE, index_x_test = c(140))
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
mdskins = cmdscale(kinshipdelta, k=3, eig=TRUE)
names(mdskins)
mdskins$points
Distnew=as.matrix(dist(mdskins$points))
cmdscale(kinshipdelta, k=3, eig=TRUE)$GOF
mdskins = cmdscale(kinshipdelta, k=3, eig=TRUE)
names(mdskins)
mdskins$points
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_marginal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
# Elemento de la matriz en el que se alcanza el máximo
(M = which.max(Distnew))
Distnew[M] # Valor del máximo
Distnew[1,]
# Otra forma de encontrar en que fila y columna se verifica una determinada condición
which(Distnew == max(Distnew), arr.ind = TRUE)
plot(mdskins$points[,1], mdskins$points[,2], type = "n", xlab = "coord 1", ylab = "Coord 2", asp=1,
main = "MDS métrico. kinshipdelta")
text(mdskins$points[,1], mdskins$points[,2], rownames(mdskins$points), cex = 0.7,col=4)
abline(h=0)
abline(v=0)
plot(mdskins$points[,1], mdskins$points[,3], type = "n", xlab = "coord 1", ylab = "Coord 3", asp=1,
main = "MDS métrico. kinshipdelta")
text(mdskins$points[,1], mdskins$points[,3], rownames(mdskins$points), cex = 0.7,col=4)
abline(h=0)
abline(v=0)
plot(mdskins$points[,2], mdskins$points[,3], type = "n", xlab = "coord 2", ylab = "Coord 3", asp=1,
main = "MDS métrico. kinshipdelta")
text(mdskins$points[,2], mdskins$points[,3], rownames(mdskins$points), cex = 0.7,col=4)
abline(h=0)
abline(v=0)
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
sina_asymmetric_causal
# Dimensiones 2 y 3
plot(mdskins$points[,2], mdskins$points[,3], type = "n", xlab = "coord 2", ylab = "Coord 3", asp=1,
main = "MDS métrico. kinshipdelta")
text(mdskins$points[,2], mdskins$points[,3], rownames(mdskins$points), cex = 0.7,col=4)
abline(h=0)
abline(v=0)
sina_asymmetric_causal
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_marginal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
plotting_dt[, `:=`(description, factor(description,
levels = unique(description[abs(phi)])))]
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_marginal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_marginal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
library(labdsv)
data(bryceveg)
names(bryceveg)
dim(bryceveg)
bryceveg[155:160,1:7]
# Distancia de Bray-Curtis
nobs = dim(bryceveg)[1] # Número de observaciones (parcelas)
dobs = dim(bryceveg)[2] # Número de variables (conteo de plantas de cada especies)
nobs
dobs
# Si queremos hacer los cálculos directamente se puede implementar por ejemplo
# como sigue o bien recurrir a la función vegdist de la librería vegan que lo
# hace de forma mucho más rápida
BCdis = matrix(0,nrow=nobs, ncol = nobs) # Matriz de distancias de B.C
for(k in 2:nobs) {
a=k-1
for(h in 1:a) {
num=0
den=0
for(i in 1:dobs) {
num = num+abs(bryceveg[k,i] - bryceveg[h,i])
den = den + (bryceveg[k,i] + bryceveg[h,i])
}
BCdis[k,h]= num/den
BCdis[h,k]= BCdis[k,h]
}
}
BCdis[1:4,1:4]
dim(BCdis)
library(vegan)
BC = vegdist(bryceveg, method="bray")
as.matrix(BC)[1:4,1:4] #comprobación
sum(as.matrix(BCdis) != as.matrix(BC))
cmdscale(BCdis, k = 2, eig = TRUE)$eig
cmdscale(BCdis, k = 1, eig = TRUE)$GOF
cmdscale(BCdis, k = 2, eig = TRUE)$GOF
cmdscale(BCdis, k = 3, eig = TRUE)$GOF
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_marginal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
solmds = cmdscale(BCdis, k = 2)
solmds # Coordenadas
#Todos los puntos a la vez no se distinguen bien:
plot(solmds[,1],solmds[,2], pch=18,col=4,xlab="Coord1",ylab="Coord2")
# Todos los puntos a la vez no se distinguen bien:
plot(solmds[,1],solmds[,2], pch=18,col=4,xlab="Coord1",ylab="Coord2")
text(solmds[,1],solmds[,2], rownames(bryceveg), pos=1, cex = 0.9,col=4)
abline(h=0,v=0,lty=2)
#Por regiones
plot(solmds[,1],solmds[,2], pch=18,col=4, xlim=c(-0.1,0.1),xlab="Coord1",ylab="Coord2")
text(solmds[,1],solmds[,2], rownames(bryceveg), pos=1, cex = 0.9,col=4)
abline(h=0,v=0,lty=2)
plot(solmds[,1],solmds[,2], pch=18,col=4,
xlim=c(0.4,0.5),ylim=c(0.1,0.25),
xlab="Coord1",ylab="Coord2")
text(solmds[,1],solmds[,2], rownames(bryceveg), pos=1, cex = 0.9,col=4)
abline(h=0,v=0)
plot(solmds[,1],solmds[,2], pch=18,col=4,
xlim=c(0.4,0.5),ylim=c(0.1,0.25),
xlab="Coord1",ylab="Coord2")
text(solmds[,1],solmds[,2], rownames(bryceveg), pos=1, cex = 0.9,col=4)
abline(h=0,v=0)
#Por regiones
plot(solmds[,1],solmds[,2], pch=18,col=4, xlim=c(-0.1,0.1),xlab="Coord1",ylab="Coord2")
text(solmds[,1],solmds[,2], rownames(bryceveg), pos=1, cex = 0.9,col=4)
abline(h=0,v=0,lty=2)
plot(solmds[,1],solmds[,2], pch=18,col=4,
xlim=c(0.4,0.5),ylim=c(0.1,0.25),
xlab="Coord1",ylab="Coord2")
abline(h=0,v=0)
library(corrplot)
corrplot(cor(bryceveg[,1:20],solmds))
corrplot(cor(bryceveg[,21:40],solmds))
corrplot(cor(bryceveg[,41:60],solmds))
corrplot(cor(bryceveg[,61:80],solmds))
corrplot(cor(bryceveg[,81:100],solmds))
corrplot(cor(bryceveg[,101:120],solmds))
corrplot(cor(bryceveg[,121:140],solmds))
corrplot(cor(bryceveg[,141:160],solmds))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
Matcorrel=cor(bryceveg,solmds)
# Variables (especies) correladas positivamente con la primera coordenada
Matcorrel[Matcorrel[,1]>0.5,]
# Variables (especies) correladas negativamente con la primera coordenada
Matcorrel[Matcorrel[,1]< -0.5,]
# Variables (especies) correladas positivamente con la segunda coordenada
Matcorrel[Matcorrel[,2]>0.5,]
# Variables (especies) correladas negativamente con la segunda coordenada
(Matcorrel[Matcorrel[,2]< -0.5,])
#para que salgan los nombres
for (i in 1:dobs) {
if (Matcorrel[i,2]< -0.5)
print(c(colnames(bryceveg)[i],Matcorrel[i,1:2]))
}
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
sina_asymmetric_causal
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_marginal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
explanation_causal
saveRDS(explanation_causal, file = "explanation_causal.rds")
DEC = dist(bryceveg)
str(DEC)
t(sapply(1:20), function(k) cmdscale(DEC, k = k, eig = TRUE)$GOF)
t(sapply(1:20, function(k) cmdscale(DEC, k = k, eig = TRUE)$GOF))
cbind(cmdscale(DEC, k = 2, eig = TRUE)$eig)
round(cbind(cmdscale(DEC, k = 2, eig = TRUE)$eig), 2)
solmds = cmdscale(DEC, k = 2)
solmds # Coordenadas
# Todos los puntos a la vez no se distinguen bien:
plot(solmds[,1],solmds[,2], pch=18,col=4,xlab="Coord1",ylab="Coord2")
text(solmds[,1],solmds[,2], rownames(bryceveg), pos=1, cex = 0.9,col=4)
abline(h=0,v=0,lty=2)
Matcorrel=cor(bryceveg,solmds)
# Variables (especies) correladas positivamente con la primera coordenada
Matcorrel[Matcorrel[,1]>0.5,]
# Variables (especies) correladas positivamente con la primera coordenada
Matcorrel[Matcorrel[,1]>0.5,1]
# Variables (especies) correladas negativamente con la primera coordenada
Matcorrel[Matcorrel[,1]< -0.5, 1]
# Variables (especies) correladas positivamente con la primera coordenada
Matcorrel[Matcorrel[,2]>0.5, 2]
# Variables (especies) correladas negativamente con la primera coordenada
Matcorrel[Matcorrel[,2]< -0.5, 2]
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_marginal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
source("extra/indiv_plot.R")
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_marginal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_causal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_marginal, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric, plot_phi0 = FALSE, index_x_test = c(140))
indiv_plot(explanation_asymmetric_causal, plot_phi0 = FALSE, index_x_test = c(140))
explainer_asymmetric <- shapr(x_train, modelrf, asymmetric = TRUE, ordering = partial_order)
